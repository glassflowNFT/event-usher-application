{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst createHash = require(\"create-hash\");\nconst pbkdf2_1 = require(\"pbkdf2\");\nconst randomBytes = require(\"randombytes\");\nconst _wordlists_1 = require(\"./_wordlists\");\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' + 'Please pass a 2048 word array explicitly.';\nfunction pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {\n  return Promise.resolve().then(() => new Promise((resolve, reject) => {\n    const callback = (err, derivedKey) => {\n      if (err) {\n        return reject(err);\n      } else {\n        return resolve(derivedKey);\n      }\n    };\n    pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);\n  }));\n}\nfunction normalize(str) {\n  return (str || '').normalize('NFKD');\n}\nfunction lpad(str, padString, length) {\n  while (str.length < length) {\n    str = padString + str;\n  }\n  return str;\n}\nfunction binaryToByte(bin) {\n  return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n  return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n  const ENT = entropyBuffer.length * 8;\n  const CS = ENT / 32;\n  const hash = createHash('sha256').update(entropyBuffer).digest();\n  return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\nfunction salt(password) {\n  return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n  const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n  const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n  return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n  return Promise.resolve().then(() => {\n    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n    return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n  });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  wordlist = wordlist || DEFAULT_WORDLIST;\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n  const words = normalize(mnemonic).split(' ');\n  if (words.length % 3 !== 0) {\n    throw new Error(INVALID_MNEMONIC);\n  }\n  // convert word indices to 11 bit binary strings\n  const bits = words.map(word => {\n    const index = wordlist.indexOf(word);\n    if (index === -1) {\n      throw new Error(INVALID_MNEMONIC);\n    }\n    return lpad(index.toString(2), '0', 11);\n  }).join('');\n  // split the binary string into ENT/CS\n  const dividerIndex = Math.floor(bits.length / 33) * 32;\n  const entropyBits = bits.slice(0, dividerIndex);\n  const checksumBits = bits.slice(dividerIndex);\n  // calculate the checksum and compare\n  const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n  if (entropyBytes.length < 16) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  if (entropyBytes.length > 32) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  if (entropyBytes.length % 4 !== 0) {\n    throw new Error(INVALID_ENTROPY);\n  }\n  const entropy = Buffer.from(entropyBytes);\n  const newChecksum = deriveChecksumBits(entropy);\n  if (newChecksum !== checksumBits) {\n    throw new Error(INVALID_CHECKSUM);\n  }\n  return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n  if (!Buffer.isBuffer(entropy)) {\n    entropy = Buffer.from(entropy, 'hex');\n  }\n  wordlist = wordlist || DEFAULT_WORDLIST;\n  if (!wordlist) {\n    throw new Error(WORDLIST_REQUIRED);\n  }\n  // 128 <= ENT <= 256\n  if (entropy.length < 16) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n  if (entropy.length > 32) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n  if (entropy.length % 4 !== 0) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n  const entropyBits = bytesToBinary(Array.from(entropy));\n  const checksumBits = deriveChecksumBits(entropy);\n  const bits = entropyBits + checksumBits;\n  const chunks = bits.match(/(.{1,11})/g);\n  const words = chunks.map(binary => {\n    const index = binaryToByte(binary);\n    return wordlist[index];\n  });\n  return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n  ? words.join('\\u3000') : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n  strength = strength || 128;\n  if (strength % 32 !== 0) {\n    throw new TypeError(INVALID_ENTROPY);\n  }\n  rng = rng || randomBytes;\n  return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n  const result = _wordlists_1.wordlists[language];\n  if (result) {\n    DEFAULT_WORDLIST = result;\n  } else {\n    throw new Error('Could not find wordlist for language \"' + language + '\"');\n  }\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n  if (!DEFAULT_WORDLIST) {\n    throw new Error('No Default Wordlist set');\n  }\n  return Object.keys(_wordlists_1.wordlists).filter(lang => {\n    if (lang === 'JA' || lang === 'EN') {\n      return false;\n    }\n    return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n  })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = require(\"./_wordlists\");\nexports.wordlists = _wordlists_2.wordlists;","map":{"version":3,"names":["Object","defineProperty","exports","value","createHash","require","pbkdf2_1","randomBytes","_wordlists_1","DEFAULT_WORDLIST","_default","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","WORDLIST_REQUIRED","pbkdf2Promise","password","saltMixin","iterations","keylen","digest","Promise","resolve","then","reject","callback","err","derivedKey","pbkdf2","normalize","str","lpad","padString","length","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","x","toString","join","deriveChecksumBits","entropyBuffer","ENT","CS","hash","update","Array","from","slice","salt","mnemonicToSeedSync","mnemonic","mnemonicBuffer","Buffer","saltBuffer","pbkdf2Sync","mnemonicToSeed","mnemonicToEntropy","wordlist","Error","words","split","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","newChecksum","entropyToMnemonic","isBuffer","TypeError","chunks","binary","generateMnemonic","strength","rng","validateMnemonic","e","setDefaultWordlist","language","result","wordlists","getDefaultWordlist","keys","filter","lang","every","_wordlists_2"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/bip39/src/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst createHash = require(\"create-hash\");\nconst pbkdf2_1 = require(\"pbkdf2\");\nconst randomBytes = require(\"randombytes\");\nconst _wordlists_1 = require(\"./_wordlists\");\nlet DEFAULT_WORDLIST = _wordlists_1._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' +\n    'Please pass a 2048 word array explicitly.';\nfunction pbkdf2Promise(password, saltMixin, iterations, keylen, digest) {\n    return Promise.resolve().then(() => new Promise((resolve, reject) => {\n        const callback = (err, derivedKey) => {\n            if (err) {\n                return reject(err);\n            }\n            else {\n                return resolve(derivedKey);\n            }\n        };\n        pbkdf2_1.pbkdf2(password, saltMixin, iterations, keylen, digest, callback);\n    }));\n}\nfunction normalize(str) {\n    return (str || '').normalize('NFKD');\n}\nfunction lpad(str, padString, length) {\n    while (str.length < length) {\n        str = padString + str;\n    }\n    return str;\n}\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n    return bytes.map((x) => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = createHash('sha256')\n        .update(entropyBuffer)\n        .digest();\n    return bytesToBinary(Array.from(hash)).slice(0, CS);\n}\nfunction salt(password) {\n    return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n    const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n    const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n    return pbkdf2_1.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n    return Promise.resolve().then(() => {\n        const mnemonicBuffer = Buffer.from(normalize(mnemonic), 'utf8');\n        const saltBuffer = Buffer.from(salt(normalize(password)), 'utf8');\n        return pbkdf2Promise(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n    });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    const words = normalize(mnemonic).split(' ');\n    if (words.length % 3 !== 0) {\n        throw new Error(INVALID_MNEMONIC);\n    }\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map((word) => {\n        const index = wordlist.indexOf(word);\n        if (index === -1) {\n            throw new Error(INVALID_MNEMONIC);\n        }\n        return lpad(index.toString(2), '0', 11);\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    if (entropyBytes.length > 32) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    if (entropyBytes.length % 4 !== 0) {\n        throw new Error(INVALID_ENTROPY);\n    }\n    const entropy = Buffer.from(entropyBytes);\n    const newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits) {\n        throw new Error(INVALID_CHECKSUM);\n    }\n    return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy)) {\n        entropy = Buffer.from(entropy, 'hex');\n    }\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    // 128 <= ENT <= 256\n    if (entropy.length < 16) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    if (entropy.length > 32) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    if (entropy.length % 4 !== 0) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    const entropyBits = bytesToBinary(Array.from(entropy));\n    const checksumBits = deriveChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = chunks.map((binary) => {\n        const index = binaryToByte(binary);\n        return wordlist[index];\n    });\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n        ? words.join('\\u3000')\n        : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0) {\n        throw new TypeError(INVALID_ENTROPY);\n    }\n    rng = rng || randomBytes;\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n    const result = _wordlists_1.wordlists[language];\n    if (result) {\n        DEFAULT_WORDLIST = result;\n    }\n    else {\n        throw new Error('Could not find wordlist for language \"' + language + '\"');\n    }\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST) {\n        throw new Error('No Default Wordlist set');\n    }\n    return Object.keys(_wordlists_1.wordlists).filter((lang) => {\n        if (lang === 'JA' || lang === 'EN') {\n            return false;\n        }\n        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n    })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = require(\"./_wordlists\");\nexports.wordlists = _wordlists_2.wordlists;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}