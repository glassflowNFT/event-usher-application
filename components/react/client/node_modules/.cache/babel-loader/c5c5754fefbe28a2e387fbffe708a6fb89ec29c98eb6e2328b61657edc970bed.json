{"ast":null,"code":"var ERRORS = require('./errors');\nvar NATIVE = require('./native');\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON;\nvar TfTypeError = ERRORS.TfTypeError;\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError;\nvar tfSubError = ERRORS.tfSubError;\nvar getValueTypeName = ERRORS.getValueTypeName;\nvar TYPES = {\n  arrayOf: function arrayOf(type, options) {\n    type = compile(type);\n    options = options || {};\n    function _arrayOf(array, strict) {\n      if (!NATIVE.Array(array)) return false;\n      if (NATIVE.Nil(array)) return false;\n      if (options.minLength !== undefined && array.length < options.minLength) return false;\n      if (options.maxLength !== undefined && array.length > options.maxLength) return false;\n      if (options.length !== undefined && array.length !== options.length) return false;\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict);\n        } catch (e) {\n          throw tfSubError(e, i);\n        }\n      });\n    }\n    _arrayOf.toJSON = function () {\n      var str = '[' + tfJSON(type) + ']';\n      if (options.length !== undefined) {\n        str += '{' + options.length + '}';\n      } else if (options.minLength !== undefined || options.maxLength !== undefined) {\n        str += '{' + (options.minLength === undefined ? 0 : options.minLength) + ',' + (options.maxLength === undefined ? Infinity : options.maxLength) + '}';\n      }\n      return str;\n    };\n    return _arrayOf;\n  },\n  maybe: function maybe(type) {\n    type = compile(type);\n    function _maybe(value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe);\n    }\n    _maybe.toJSON = function () {\n      return '?' + tfJSON(type);\n    };\n    return _maybe;\n  },\n  map: function map(propertyType, propertyKeyType) {\n    propertyType = compile(propertyType);\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType);\n    function _map(value, strict) {\n      if (!NATIVE.Object(value)) return false;\n      if (NATIVE.Nil(value)) return false;\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict);\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key');\n        }\n        try {\n          var propertyValue = value[propertyName];\n          typeforce(propertyType, propertyValue, strict);\n        } catch (e) {\n          throw tfSubError(e, propertyName);\n        }\n      }\n      return true;\n    }\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}';\n      };\n    } else {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyType) + '}';\n      };\n    }\n    return _map;\n  },\n  object: function object(uncompiled) {\n    var type = {};\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName]);\n    }\n    function _object(value, strict) {\n      if (!NATIVE.Object(value)) return false;\n      if (NATIVE.Nil(value)) return false;\n      var propertyName;\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName];\n          var propertyValue = value[propertyName];\n          typeforce(propertyType, propertyValue, strict);\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName);\n      }\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue;\n          throw new TfPropertyTypeError(undefined, propertyName);\n        }\n      }\n      return true;\n    }\n    _object.toJSON = function () {\n      return tfJSON(type);\n    };\n    return _object;\n  },\n  anyOf: function anyOf() {\n    var types = [].slice.call(arguments).map(compile);\n    function _anyOf(value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict);\n        } catch (e) {\n          return false;\n        }\n      });\n    }\n    _anyOf.toJSON = function () {\n      return types.map(tfJSON).join('|');\n    };\n    return _anyOf;\n  },\n  allOf: function allOf() {\n    var types = [].slice.call(arguments).map(compile);\n    function _allOf(value, strict) {\n      return types.every(function (type) {\n        try {\n          return typeforce(type, value, strict);\n        } catch (e) {\n          return false;\n        }\n      });\n    }\n    _allOf.toJSON = function () {\n      return types.map(tfJSON).join(' & ');\n    };\n    return _allOf;\n  },\n  quacksLike: function quacksLike(type) {\n    function _quacksLike(value) {\n      return type === getValueTypeName(value);\n    }\n    _quacksLike.toJSON = function () {\n      return type;\n    };\n    return _quacksLike;\n  },\n  tuple: function tuple() {\n    var types = [].slice.call(arguments).map(compile);\n    function _tuple(values, strict) {\n      if (NATIVE.Nil(values)) return false;\n      if (NATIVE.Nil(values.length)) return false;\n      if (strict && values.length !== types.length) return false;\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict);\n        } catch (e) {\n          throw tfSubError(e, i);\n        }\n      });\n    }\n    _tuple.toJSON = function () {\n      return '(' + types.map(tfJSON).join(', ') + ')';\n    };\n    return _tuple;\n  },\n  value: function value(expected) {\n    function _value(actual) {\n      return actual === expected;\n    }\n    _value.toJSON = function () {\n      return expected;\n    };\n    return _value;\n  }\n};\n\n// TODO: deprecate\nTYPES.oneOf = TYPES.anyOf;\nfunction compile(type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(type.slice(1));\n    return NATIVE[type] || TYPES.quacksLike(type);\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) {\n      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1');\n      return TYPES.arrayOf(type[0]);\n    }\n    return TYPES.object(type);\n  } else if (NATIVE.Function(type)) {\n    return type;\n  }\n  return TYPES.value(type);\n}\nfunction typeforce(type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true;\n    throw new TfTypeError(surrogate || type, value);\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict);\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName];\n}\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName];\n}\nvar EXTRA = require('./extra');\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName];\n}\ntypeforce.compile = compile;\ntypeforce.TfTypeError = TfTypeError;\ntypeforce.TfPropertyTypeError = TfPropertyTypeError;\nmodule.exports = typeforce;","map":{"version":3,"names":["ERRORS","require","NATIVE","tfJSON","TfTypeError","TfPropertyTypeError","tfSubError","getValueTypeName","TYPES","arrayOf","type","options","compile","_arrayOf","array","strict","Array","Nil","minLength","undefined","length","maxLength","every","value","i","typeforce","e","toJSON","str","Infinity","maybe","_maybe","map","propertyType","propertyKeyType","_map","Object","propertyName","propertyValue","object","uncompiled","typePropertyName","_object","anyOf","types","slice","call","arguments","_anyOf","some","join","allOf","_allOf","quacksLike","_quacksLike","tuple","_tuple","values","expected","_value","actual","oneOf","String","TypeError","Function","surrogate","typeName","EXTRA","module","exports"],"sources":["/Users/seanwavy/Development/legends/event-usher-application/components/react/client/node_modules/typeforce/index.js"],"sourcesContent":["var ERRORS = require('./errors')\nvar NATIVE = require('./native')\n\n// short-hand\nvar tfJSON = ERRORS.tfJSON\nvar TfTypeError = ERRORS.TfTypeError\nvar TfPropertyTypeError = ERRORS.TfPropertyTypeError\nvar tfSubError = ERRORS.tfSubError\nvar getValueTypeName = ERRORS.getValueTypeName\n\nvar TYPES = {\n  arrayOf: function arrayOf (type, options) {\n    type = compile(type)\n    options = options || {}\n\n    function _arrayOf (array, strict) {\n      if (!NATIVE.Array(array)) return false\n      if (NATIVE.Nil(array)) return false\n      if (options.minLength !== undefined && array.length < options.minLength) return false\n      if (options.maxLength !== undefined && array.length > options.maxLength) return false\n      if (options.length !== undefined && array.length !== options.length) return false\n\n      return array.every(function (value, i) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _arrayOf.toJSON = function () {\n      var str = '[' + tfJSON(type) + ']'\n      if (options.length !== undefined) {\n        str += '{' + options.length + '}'\n      } else if (options.minLength !== undefined || options.maxLength !== undefined) {\n        str += '{' +\n          (options.minLength === undefined ? 0 : options.minLength) + ',' +\n          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'\n      }\n      return str\n    }\n\n    return _arrayOf\n  },\n\n  maybe: function maybe (type) {\n    type = compile(type)\n\n    function _maybe (value, strict) {\n      return NATIVE.Nil(value) || type(value, strict, maybe)\n    }\n    _maybe.toJSON = function () { return '?' + tfJSON(type) }\n\n    return _maybe\n  },\n\n  map: function map (propertyType, propertyKeyType) {\n    propertyType = compile(propertyType)\n    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)\n\n    function _map (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      for (var propertyName in value) {\n        try {\n          if (propertyKeyType) {\n            typeforce(propertyKeyType, propertyName, strict)\n          }\n        } catch (e) {\n          throw tfSubError(e, propertyName, 'key')\n        }\n\n        try {\n          var propertyValue = value[propertyName]\n          typeforce(propertyType, propertyValue, strict)\n        } catch (e) {\n          throw tfSubError(e, propertyName)\n        }\n      }\n\n      return true\n    }\n\n    if (propertyKeyType) {\n      _map.toJSON = function () {\n        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'\n      }\n    } else {\n      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }\n    }\n\n    return _map\n  },\n\n  object: function object (uncompiled) {\n    var type = {}\n\n    for (var typePropertyName in uncompiled) {\n      type[typePropertyName] = compile(uncompiled[typePropertyName])\n    }\n\n    function _object (value, strict) {\n      if (!NATIVE.Object(value)) return false\n      if (NATIVE.Nil(value)) return false\n\n      var propertyName\n\n      try {\n        for (propertyName in type) {\n          var propertyType = type[propertyName]\n          var propertyValue = value[propertyName]\n\n          typeforce(propertyType, propertyValue, strict)\n        }\n      } catch (e) {\n        throw tfSubError(e, propertyName)\n      }\n\n      if (strict) {\n        for (propertyName in value) {\n          if (type[propertyName]) continue\n\n          throw new TfPropertyTypeError(undefined, propertyName)\n        }\n      }\n\n      return true\n    }\n    _object.toJSON = function () { return tfJSON(type) }\n\n    return _object\n  },\n\n  anyOf: function anyOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _anyOf (value, strict) {\n      return types.some(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }\n\n    return _anyOf\n  },\n\n  allOf: function allOf () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _allOf (value, strict) {\n      return types.every(function (type) {\n        try {\n          return typeforce(type, value, strict)\n        } catch (e) {\n          return false\n        }\n      })\n    }\n    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }\n\n    return _allOf\n  },\n\n  quacksLike: function quacksLike (type) {\n    function _quacksLike (value) {\n      return type === getValueTypeName(value)\n    }\n    _quacksLike.toJSON = function () { return type }\n\n    return _quacksLike\n  },\n\n  tuple: function tuple () {\n    var types = [].slice.call(arguments).map(compile)\n\n    function _tuple (values, strict) {\n      if (NATIVE.Nil(values)) return false\n      if (NATIVE.Nil(values.length)) return false\n      if (strict && (values.length !== types.length)) return false\n\n      return types.every(function (type, i) {\n        try {\n          return typeforce(type, values[i], strict)\n        } catch (e) {\n          throw tfSubError(e, i)\n        }\n      })\n    }\n    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }\n\n    return _tuple\n  },\n\n  value: function value (expected) {\n    function _value (actual) {\n      return actual === expected\n    }\n    _value.toJSON = function () { return expected }\n\n    return _value\n  }\n}\n\n// TODO: deprecate\nTYPES.oneOf = TYPES.anyOf\n\nfunction compile (type) {\n  if (NATIVE.String(type)) {\n    if (type[0] === '?') return TYPES.maybe(type.slice(1))\n\n    return NATIVE[type] || TYPES.quacksLike(type)\n  } else if (type && NATIVE.Object(type)) {\n    if (NATIVE.Array(type)) {\n      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')\n      return TYPES.arrayOf(type[0])\n    }\n\n    return TYPES.object(type)\n  } else if (NATIVE.Function(type)) {\n    return type\n  }\n\n  return TYPES.value(type)\n}\n\nfunction typeforce (type, value, strict, surrogate) {\n  if (NATIVE.Function(type)) {\n    if (type(value, strict)) return true\n\n    throw new TfTypeError(surrogate || type, value)\n  }\n\n  // JIT\n  return typeforce(compile(type), value, strict)\n}\n\n// assign types to typeforce function\nfor (var typeName in NATIVE) {\n  typeforce[typeName] = NATIVE[typeName]\n}\n\nfor (typeName in TYPES) {\n  typeforce[typeName] = TYPES[typeName]\n}\n\nvar EXTRA = require('./extra')\nfor (typeName in EXTRA) {\n  typeforce[typeName] = EXTRA[typeName]\n}\n\ntypeforce.compile = compile\ntypeforce.TfTypeError = TfTypeError\ntypeforce.TfPropertyTypeError = TfPropertyTypeError\n\nmodule.exports = typeforce\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}